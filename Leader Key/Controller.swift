import Cocoa
import Combine
import Defaults
import SwiftUI
import Carbon.HIToolbox

// Define a unique tag for synthetic events generated by Leader Key
private let leaderKeySyntheticEventTag: Int64 = 0xDEADBEEF // Use a unique value

enum KeyHelpers: UInt16 {
  case enter = 36
  case tab = 48
  case space = 49
  case backspace = 51
  case escape = 53
  case upArrow = 126
  case downArrow = 125
  case leftArrow = 123
  case rightArrow = 124
}

class Controller {
  var userState: UserState
  var userConfig: UserConfig
  weak var appDelegate: AppDelegate? // Add weak reference to AppDelegate

  var window: MainWindow!
  var cheatsheetWindow: NSWindow!
  private var cheatsheetTimer: Timer?

  private var cancellables = Set<AnyCancellable>()

  init(userState: UserState, userConfig: UserConfig, appDelegate: AppDelegate) {
    self.userState = userState
    self.userConfig = userConfig
    self.appDelegate = appDelegate // Store the reference

    Task {
      for await value in Defaults.updates(.theme) {
        let windowClass = Theme.classFor(value)
        self.window = await windowClass.init(controller: self)
      }
    }

    Events.sink { event in
      switch event {
      case .didReload:
        // This should all be handled by the themes
        self.userState.isShowingRefreshState = true
        self.show()
        // Delay for 4 * 300ms to wait for animation to be noticeable
        delay(Int(Pulsate.singleDurationS * 1000) * 3) {
          self.hide()
          self.userState.isShowingRefreshState = false
        }
      default: break
      }
    }.store(in: &cancellables)

    self.cheatsheetWindow = Cheatsheet.createWindow(for: userState)
  }

  func show() {
    show(completion: nil)
  }

  // Define an enum for activation type
  enum ActivationType {
      case defaultOnly
      case appSpecificWithFallback
  }

  func show(type: ActivationType = .appSpecificWithFallback, completion: (() -> Void)? = nil) {
    Events.send(.willActivate)

    // Determine which config to load based on type
    let configToLoad: Group
    switch type {
    case .defaultOnly:
      configToLoad = userConfig.root // Use the already loaded default config
    case .appSpecificWithFallback:
      let frontmostApp = NSWorkspace.shared.frontmostApplication
      let bundleId = frontmostApp?.bundleIdentifier
      configToLoad = userConfig.getConfig(for: bundleId) // Use the enhanced getter
    }

    userState.activeRoot = configToLoad // Update UserState with the selected config

    window.show {
      Events.send(.didActivate)
      completion?()
    }

    if !window.hasCheatsheet || userState.isShowingRefreshState {
      return
    }

    switch Defaults[.autoOpenCheatsheet] {
    case .always:
      showCheatsheet()
    case .delay:
      scheduleCheatsheet()
    default: break
    }
  }

  func hide(afterClose: (() -> Void)? = nil) {
    Events.send(.willDeactivate)

    window.hide {
      self.clear()
      afterClose?()
      Events.send(.didDeactivate)
    }

    cheatsheetWindow?.orderOut(nil)
    cheatsheetTimer?.invalidate()
  }

  func keyDown(with event: NSEvent) {
    // Reset the delay timer
    if Defaults[.autoOpenCheatsheet] == .delay {
      scheduleCheatsheet()
    }

    // Handle Command key shortcuts when the window is key
    if event.modifierFlags.contains(.command) {
      switch event.charactersIgnoringModifiers {
      case ",":
        print("[Controller] Cmd+, detected. Opening settings.")
        NSApp.sendAction(
          #selector(AppDelegate.settingsMenuItemActionHandler(_:)), to: nil,
          from: nil)
        hide() // Hide the main window when settings open
        return // Consume the event
      case "w":
         print("[Controller] Cmd+w detected. Hiding window.")
         hide()
         return // Consume the event
      case "q":
         print("[Controller] Cmd+q detected. Terminating app.")
         NSApp.terminate(nil)
         return // Consume the event
      default:
        print("[Controller] Unhandled Cmd+Key: \(event.charactersIgnoringModifiers ?? "nil")")
        break // Let other Cmd key combinations pass through if needed
      }
    }

    // Handle non-Command key presses for sequence/navigation
    switch event.keyCode {
    case KeyHelpers.backspace.rawValue:
      clear()
      delay(1) {
        self.positionCheatsheetWindow()
      }
    case KeyHelpers.escape.rawValue:
      hide()
      return
    default:
      guard let char = charForEvent(event) else { return }
      handleKey(char, withModifiers: event.modifierFlags)
    }
  }

  func handleKey(_ key: String, withModifiers modifiers: NSEvent.ModifierFlags? = nil) {
    if key == "?" {
      showCheatsheet()
      return
    }

    // Use the activeRoot from UserState, fallback to default userConfig.root if needed
    let activeList = userState.activeRoot ?? userConfig.root
    let list =
      (userState.currentGroup != nil)
      ? userState.currentGroup : activeList // Start search from active root

    let hit = list?.actions.first { item in
      switch item {
      case .group(let group):
        if group.key == key {
          return true
        }
      case .action(let action):
        if action.key == key {
          return true
        }
      }
      return false
    }

    switch hit {
    case .action(let action):
      if let mods = modifiers, isInStickyMode(mods) {
        runAction(action)
      } else {
        hide {
          self.runAction(action)
        }
      }
    case .group(let group):
      if let mods = modifiers, shouldRunGroupSequenceWithModifiers(mods) {
        hide {
          self.runGroup(group)
        }
      } else {
        userState.display = group.key
        userState.navigateToGroup(group)
      }
    case .none:
      window.notFound()
    }

    // Why do we need to wait here?
    delay(1) {
      self.positionCheatsheetWindow()
    }
  }

  private func shouldRunGroupSequence(_ event: NSEvent) -> Bool {
    return shouldRunGroupSequenceWithModifiers(event.modifierFlags)
  }

  private func shouldRunGroupSequenceWithModifiers(_ modifierFlags: NSEvent.ModifierFlags) -> Bool {
    let config = Defaults[.modifierKeyConfiguration]

    switch config {
    case .controlGroupOptionSticky:
      return modifierFlags.contains(.control)
    case .optionGroupControlSticky:
      return modifierFlags.contains(.option)
    }
  }

  private func isInStickyMode(_ modifierFlags: NSEvent.ModifierFlags) -> Bool {
    let config = Defaults[.modifierKeyConfiguration]

    switch config {
    case .controlGroupOptionSticky:
      return modifierFlags.contains(.option)
    case .optionGroupControlSticky:
      return modifierFlags.contains(.control)
    }
  }

  private func charForEvent(_ event: NSEvent) -> String? {
    if Defaults[.forceEnglishKeyboardLayout] {
      if let mapped = englishKeymap[event.keyCode] {
        // Check if Shift is pressed and convert to uppercase if so
        if event.modifierFlags.contains(.shift) {
          return mapped.uppercased()
        }

        return mapped
      }
    }

    // Handle special keys
    switch event.keyCode {
    case KeyHelpers.enter.rawValue:
      return "↵"
    case KeyHelpers.upArrow.rawValue:
      return "↑"
    case KeyHelpers.downArrow.rawValue:
      return "↓"
    case KeyHelpers.leftArrow.rawValue:
      return "←"
    case KeyHelpers.rightArrow.rawValue:
      return "→"
    default:
      return event.charactersIgnoringModifiers
    }
  }

  private func positionCheatsheetWindow() {
    guard let mainWindow = window, let cheatsheet = cheatsheetWindow else {
      return
    }

    cheatsheet.setFrameOrigin(
      mainWindow.cheatsheetOrigin(cheatsheetSize: cheatsheet.frame.size))
  }

  private func showCheatsheet() {
    if !window.hasCheatsheet {
      return
    }
    positionCheatsheetWindow()
    cheatsheetWindow?.orderFront(nil)
  }

  private func scheduleCheatsheet() {
    cheatsheetTimer?.invalidate()

    cheatsheetTimer = Timer.scheduledTimer(
      withTimeInterval: Double(Defaults[.cheatsheetDelayMS]) / 1000.0, repeats: false
    ) { [weak self] _ in
      self?.showCheatsheet()
    }
  }

  func runGroup(_ group: Group) {
    for groupOrAction in group.actions {
      switch groupOrAction {
      case .group(let group):
        runGroup(group)
      case .action(let action):
        runAction(action)
      }
    }
  }

  func runAction(_ action: Action) {
    switch action.type {
    case .application:
      NSWorkspace.shared.openApplication(
        at: URL(fileURLWithPath: action.value),
        configuration: NSWorkspace.OpenConfiguration())
    case .url:
      openURL(action)
    case .command:
      CommandRunner.run(action.value)
    case .folder:
      let path: String = (action.value as NSString).expandingTildeInPath
      NSWorkspace.shared.selectFile(nil, inFileViewerRootedAtPath: path)
    case .shortcut:
      let success = runKeyboardShortcut(action.value)
      if !success {
        // If shortcut failed, we already showed an alert and reset state.
        // We might still need to hide if not in sticky mode, but the state is handled.
        print("[Controller] runAction: Detected shortcut failure. State should be reset by runKeyboardShortcut.")
      }
    case .text:
      typeText(action.value)
    default:
      print("\(action.type) unknown")
    }

    if window.isVisible {
      window.makeKeyAndOrderFront(nil)
    }
  }

  private func clear() {
    userState.clear() // This now also resets activeRoot in UserState
  }

  private func openURL(_ action: Action) {
    guard let url = URL(string: action.value) else {
      showAlert(
        title: "Invalid URL", message: "Failed to parse URL: \(action.value)")
      return
    }

    guard let scheme = url.scheme else {
      showAlert(
        title: "Invalid URL",
        message:
          "URL is missing protocol (e.g. https://, raycast://): \(action.value)"
      )
      return
    }

    // Determine the configuration based on action.activates or scheme
    let configurationToUse: NSWorkspace.OpenConfiguration
    let shouldActivate: Bool

    if let explicitlySetActivates = action.activates {
      // User explicitly set the value
      shouldActivate = explicitlySetActivates
      print("[Controller] openURL: 'activates' explicitly set to \(shouldActivate) for \(action.value)")
    } else {
      // Fallback to default behavior based on scheme if activates is nil
      shouldActivate = (scheme == "http" || scheme == "https")
      print("[Controller] openURL: 'activates' not set, defaulting based on scheme ('\(scheme)') to \(shouldActivate) for \(action.value)")
    }

    if shouldActivate {
      configurationToUse = NSWorkspace.OpenConfiguration() // Default config activates
    } else {
      configurationToUse = DontActivateConfiguration.shared.configuration // Shared config does not activate
    }

    // Open the URL with the determined configuration
    NSWorkspace.shared.open(
      url,
      configuration: configurationToUse
    )
  }

  private func showAlert(title: String, message: String) {
    let alert = NSAlert()
    alert.messageText = title
    alert.informativeText = message
    alert.alertStyle = .warning
    alert.addButton(withTitle: "OK")
    alert.runModal()
  }

  // --- Text Typing Helper --- START ---
  private func typeText(_ textToType: String) {
      print("[Controller] Attempting to type text: '\(textToType)'")
      guard let source = CGEventSource(stateID: .hidSystemState) else {
          print("Error: Failed to create CGEventSource for typing.")
          showAlert(title: "Typing Error", message: "Could not create event source.")
          return
      }
      let tapLocation = CGEventTapLocation.cghidEventTap

      // Loop through each character in the string
      for character in textToType {
          // Get the Unicode value(s) for the character
          guard let utf16Values = character.unicodeScalars.first?.value else {
              print("Warning: Could not get Unicode value for character '\(character)'. Skipping.")
              continue
          }

          // Create KeyDown event
          guard let eventDown = CGEvent(keyboardEventSource: source, virtualKey: 0, keyDown: true) else { // virtualKey 0 for Unicode
              print("Error: Failed to create KeyDown CGEvent for character '\(character)'.")
              continue
          }
          var charCode = UniChar(utf16Values)
          eventDown.keyboardSetUnicodeString(stringLength: 1, unicodeString: &charCode)
          eventDown.post(tap: tapLocation)

          // Tiny delay (adjust as needed)
          // usleep(5000) // 5 milliseconds

          // Create KeyUp event
          guard let eventUp = CGEvent(keyboardEventSource: source, virtualKey: 0, keyDown: false) else { // virtualKey 0 for Unicode
              print("Error: Failed to create KeyUp CGEvent for character '\(character)'.")
              continue
          }
          eventUp.keyboardSetUnicodeString(stringLength: 1, unicodeString: &charCode)
          eventUp.post(tap: tapLocation)
          
          // Add a small delay between characters (optional, makes typing feel more natural)
          // usleep(10000) // 10 milliseconds
      }
      print("[Controller] Finished typing text.")
  }
  // --- Text Typing Helper --- END ---

  // --- Shortcut Execution Helpers --- START ---

  private func runKeyboardShortcut(_ shortcutSequenceString: String) -> Bool {
      print("[Controller] Attempting to run shortcut sequence: '\(shortcutSequenceString)'")

      // Split the sequence string by spaces
      let individualShortcutStrings = shortcutSequenceString.split(separator: " ").map(String.init)
      var parsedShortcuts: [(keyCode: CGKeyCode, flags: CGEventFlags)] = []

      // Parse each individual shortcut string
      for shortcutString in individualShortcutStrings {
          guard let eventData = parseCompactShortcutToCGEventData(shortcutString) else {
              print("[Controller] Failed to parse part '\(shortcutString)' of sequence '\(shortcutSequenceString)'")
              showAlert(
                  title: "Invalid Shortcut Sequence",
                  message: "Could not parse part '\(shortcutString)' in sequence: '\(shortcutSequenceString)'\n\nUse format like 'CSb Oa' (Cmd+Shift+b then Opt+a). Check logs for details."
              )
              print("[Controller] Shortcut parse failed. Resetting sequence state.")
              appDelegate?.resetSequenceState() // Call reset on AppDelegate
              return false // Indicate failure
          }
          parsedShortcuts.append(eventData)
      }

      // Execute the parsed shortcuts sequentially with a delay
      let delayBetweenShortcutsMicroseconds: useconds_t = 50000 // 50ms delay
      for (index, shortcutData) in parsedShortcuts.enumerated() {
          print("[Controller] Executing step \(index + 1)/\(parsedShortcuts.count): KeyCode: \(shortcutData.keyCode), Flags: \(shortcutData.flags)")
          executeShortcut(keyCode: shortcutData.keyCode, flags: shortcutData.flags)

          // Add delay *after* executing a shortcut, except for the last one
          if index < parsedShortcuts.count - 1 {
              usleep(delayBetweenShortcutsMicroseconds)
          }
      }
      print("[Controller] Finished executing shortcut sequence.")
      return true // Indicate success
  }

  private let karabinerToKeyCodeMap: [String: CGKeyCode] = [
      // Modifier Keys
      "caps_lock": CGKeyCode(kVK_CapsLock),
      "left_control": CGKeyCode(kVK_Control),
      "left_shift": CGKeyCode(kVK_Shift),
      "left_option": CGKeyCode(kVK_Option),
      "left_command": CGKeyCode(kVK_Command),
      "right_control": CGKeyCode(kVK_RightControl),
      "right_shift": CGKeyCode(kVK_RightShift),
      "right_option": CGKeyCode(kVK_RightOption),
      "right_command": CGKeyCode(kVK_RightCommand),
      "fn": CGKeyCode(kVK_Function),
      // Letters
      "a": CGKeyCode(kVK_ANSI_A), "b": CGKeyCode(kVK_ANSI_B), "c": CGKeyCode(kVK_ANSI_C),
      "d": CGKeyCode(kVK_ANSI_D), "e": CGKeyCode(kVK_ANSI_E), "f": CGKeyCode(kVK_ANSI_F),
      "g": CGKeyCode(kVK_ANSI_G), "h": CGKeyCode(kVK_ANSI_H), "i": CGKeyCode(kVK_ANSI_I),
      "j": CGKeyCode(kVK_ANSI_J), "k": CGKeyCode(kVK_ANSI_K), "l": CGKeyCode(kVK_ANSI_L),
      "m": CGKeyCode(kVK_ANSI_M), "n": CGKeyCode(kVK_ANSI_N), "o": CGKeyCode(kVK_ANSI_O),
      "p": CGKeyCode(kVK_ANSI_P), "q": CGKeyCode(kVK_ANSI_Q), "r": CGKeyCode(kVK_ANSI_R),
      "s": CGKeyCode(kVK_ANSI_S), "t": CGKeyCode(kVK_ANSI_T), "u": CGKeyCode(kVK_ANSI_U),
      "v": CGKeyCode(kVK_ANSI_V), "w": CGKeyCode(kVK_ANSI_W), "x": CGKeyCode(kVK_ANSI_X),
      "y": CGKeyCode(kVK_ANSI_Y), "z": CGKeyCode(kVK_ANSI_Z),
      // Numbers (ANSI)
      "0": CGKeyCode(kVK_ANSI_0), "1": CGKeyCode(kVK_ANSI_1), "2": CGKeyCode(kVK_ANSI_2),
      "3": CGKeyCode(kVK_ANSI_3), "4": CGKeyCode(kVK_ANSI_4), "5": CGKeyCode(kVK_ANSI_5),
      "6": CGKeyCode(kVK_ANSI_6), "7": CGKeyCode(kVK_ANSI_7), "8": CGKeyCode(kVK_ANSI_8),
      "9": CGKeyCode(kVK_ANSI_9),
      // Common Keys
      "return_or_enter": CGKeyCode(kVK_Return),
      "enter": CGKeyCode(kVK_Return), // Often the same as return
      "tab": CGKeyCode(kVK_Tab),
      "spacebar": CGKeyCode(kVK_Space),
      "delete_or_backspace": CGKeyCode(kVK_Delete), // Backspace
      "delete_forward": CGKeyCode(kVK_ForwardDelete),
      "escape": CGKeyCode(kVK_Escape),
      "home": CGKeyCode(kVK_Home),
      "end": CGKeyCode(kVK_End),
      "page_up": CGKeyCode(kVK_PageUp),
      "page_down": CGKeyCode(kVK_PageDown),
      "help": CGKeyCode(kVK_Help), // May also be Insert
      "insert": CGKeyCode(kVK_Help), // Often mapped to Help key code
      // Arrows
      "left_arrow": CGKeyCode(kVK_LeftArrow),
      "right_arrow": CGKeyCode(kVK_RightArrow),
      "down_arrow": CGKeyCode(kVK_DownArrow),
      "up_arrow": CGKeyCode(kVK_UpArrow),
      // Function Keys
      "f1": CGKeyCode(kVK_F1), "f2": CGKeyCode(kVK_F2), "f3": CGKeyCode(kVK_F3),
      "f4": CGKeyCode(kVK_F4), "f5": CGKeyCode(kVK_F5), "f6": CGKeyCode(kVK_F6),
      "f7": CGKeyCode(kVK_F7), "f8": CGKeyCode(kVK_F8), "f9": CGKeyCode(kVK_F9),
      "f10": CGKeyCode(kVK_F10), "f11": CGKeyCode(kVK_F11), "f12": CGKeyCode(kVK_F12),
      "f13": CGKeyCode(kVK_F13), "f14": CGKeyCode(kVK_F14), "f15": CGKeyCode(kVK_F15),
      "f16": CGKeyCode(kVK_F16), "f17": CGKeyCode(kVK_F17), "f18": CGKeyCode(kVK_F18),
      "f19": CGKeyCode(kVK_F19), "f20": CGKeyCode(kVK_F20),
      // Keypad
      "keypad_0": CGKeyCode(kVK_ANSI_Keypad0), "keypad_1": CGKeyCode(kVK_ANSI_Keypad1),
      "keypad_2": CGKeyCode(kVK_ANSI_Keypad2), "keypad_3": CGKeyCode(kVK_ANSI_Keypad3),
      "keypad_4": CGKeyCode(kVK_ANSI_Keypad4), "keypad_5": CGKeyCode(kVK_ANSI_Keypad5),
      "keypad_6": CGKeyCode(kVK_ANSI_Keypad6), "keypad_7": CGKeyCode(kVK_ANSI_Keypad7),
      "keypad_8": CGKeyCode(kVK_ANSI_Keypad8), "keypad_9": CGKeyCode(kVK_ANSI_Keypad9),
      "keypad_period": CGKeyCode(kVK_ANSI_KeypadDecimal),
      "keypad_enter": CGKeyCode(kVK_ANSI_KeypadEnter),
      "keypad_plus": CGKeyCode(kVK_ANSI_KeypadPlus),
      "keypad_minus": CGKeyCode(kVK_ANSI_KeypadMinus),
      "keypad_multiply": CGKeyCode(kVK_ANSI_KeypadMultiply),
      "keypad_divide": CGKeyCode(kVK_ANSI_KeypadDivide),
      "keypad_equal_sign": CGKeyCode(kVK_ANSI_KeypadEquals),
      "keypad_clear": CGKeyCode(kVK_ANSI_KeypadClear),
      "keypad_num_lock": CGKeyCode(kVK_ANSI_KeypadClear), // Often same as clear
      // Misc
      "grave_accent_and_tilde": CGKeyCode(kVK_ANSI_Grave),
      "hyphen": CGKeyCode(kVK_ANSI_Minus), // Minus
      "equal_sign": CGKeyCode(kVK_ANSI_Equal),
      "open_bracket": CGKeyCode(kVK_ANSI_LeftBracket),
      "close_bracket": CGKeyCode(kVK_ANSI_RightBracket),
      "backslash": CGKeyCode(kVK_ANSI_Backslash),
      "semicolon": CGKeyCode(kVK_ANSI_Semicolon),
      "quote": CGKeyCode(kVK_ANSI_Quote),
      "comma": CGKeyCode(kVK_ANSI_Comma),
      "period": CGKeyCode(kVK_ANSI_Period),
      "slash": CGKeyCode(kVK_ANSI_Slash),
      // Media Keys (Example - These might need special handling or different key codes)
      "volume_increment": CGKeyCode(kVK_VolumeUp),
      "volume_decrement": CGKeyCode(kVK_VolumeDown),
      "mute": CGKeyCode(kVK_Mute),
      // PC Keys (Mapped where possible)
      "print_screen": CGKeyCode(kVK_F13), // Often mapped to F13
      "scroll_lock": CGKeyCode(kVK_F14), // Often mapped to F14
      "pause": CGKeyCode(kVK_F15),       // Often mapped to F15
      // "power": CGKeyCode(kVK_Power),     // May require special handling
      // International & Language Keys (Examples)
      "lang1": CGKeyCode(kVK_JIS_Eisu),  // Assuming Eisuu for Lang1 (e.g., Hangul/English)
      "lang2": CGKeyCode(kVK_JIS_Kana),  // Assuming Kana for Lang2 (e.g., Hanja)
      "japanese_eisuu": CGKeyCode(kVK_JIS_Eisu),
      "japanese_kana": CGKeyCode(kVK_JIS_Kana),
  ]

  private func parseCompactShortcutToCGEventData(_ shortcut: String) -> (keyCode: CGKeyCode, flags: CGEventFlags)? {
      guard !shortcut.isEmpty else {
          print("Error: Shortcut string is empty.")
          return nil
      }

      var modifierFlags: CGEventFlags = [] // Start with no flags
      var remainingString = shortcut // Start with the full string

      // 1. Consume modifier characters from the beginning and set flags
      while !remainingString.isEmpty {
          let firstChar = remainingString.first!
          var consumedModifier = false

          // Modifier mapping: C=Cmd, T=Ctrl, O=Opt(Alt), S=Shift, F=Fn
          switch firstChar {
          case "C": // Was Command
              modifierFlags.insert(.maskCommand)
              consumedModifier = true
          case "T": // Was Control
              modifierFlags.insert(.maskControl)
              consumedModifier = true
          case "O": // Was Option/Alt
              modifierFlags.insert(.maskAlternate)
              consumedModifier = true
          case "S": // Was Shift
              modifierFlags.insert(.maskShift)
              consumedModifier = true
          case "F": // Was Fn
              modifierFlags.insert(.maskSecondaryFn)
              consumedModifier = true
          default:
              break // Not a modifier character
          }

          if consumedModifier {
              remainingString.removeFirst()
          } else {
              break // Stop if the character wasn't a modifier
          }
      }

      // 2. The rest of the string is the key name
      let keyName = remainingString.lowercased()

      guard !keyName.isEmpty else {
          print("Error: No key name found after modifiers in shortcut string '\(shortcut)'.")
          return nil
      }

      // 3. Map the key name string to a CGKeyCode using the standard constants map
      guard let keyCode = karabinerToKeyCodeMap[keyName] else {
          print("Error: Unknown key name '\(keyName)' in shortcut string '\(shortcut)'. Cannot map to CGKeyCode.")
          return nil
      }

      // 4. Return the key code and combined flags
      return (keyCode: keyCode, flags: modifierFlags)
  }

  private func executeShortcut(keyCode: CGKeyCode, flags: CGEventFlags) {
      // Get the system event source
      guard let source = CGEventSource(stateID: .hidSystemState) else {
          print("Error: Failed to create CGEventSource.")
          return
      }
      // Add the tag to the source
      source.userData = leaderKeySyntheticEventTag

      // Define the event tap location
      let tapLocation = CGEventTapLocation.cghidEventTap

      // 1. Create and post the Key Down event
      guard let eventDown = CGEvent(keyboardEventSource: source, virtualKey: keyCode, keyDown: true) else {
          print("Error: Failed to create KeyDown CGEvent.")
          return
      }
      eventDown.flags = flags // Apply modifier flags
      // Set the user data field to identify this as a synthetic event
      eventDown.setIntegerValueField(.eventSourceUserData, value: leaderKeySyntheticEventTag)
      eventDown.post(tap: tapLocation)
      print("Posted KeyDown: \(keyCode) with flags: \(flags)")

      // Add a small delay between down and up (optional)
      // usleep(10000) // e.g., 10 milliseconds

      // 2. Create and post the Key Up event
      guard let eventUp = CGEvent(keyboardEventSource: source, virtualKey: keyCode, keyDown: false) else {
          print("Error: Failed to create KeyUp CGEvent.")
          return
      }
      eventUp.flags = flags // Apply the *same* modifier flags
      // Set the user data field to identify this as a synthetic event
      eventUp.setIntegerValueField(.eventSourceUserData, value: leaderKeySyntheticEventTag)
      eventUp.post(tap: tapLocation)
      print("Posted KeyUp: \(keyCode) with flags: \(flags)")
  }
  // --- Shortcut Execution Helpers --- END ---
}

class DontActivateConfiguration {
  let configuration = NSWorkspace.OpenConfiguration()

  static var shared = DontActivateConfiguration()

  init() {
    configuration.activates = false
  }
}
